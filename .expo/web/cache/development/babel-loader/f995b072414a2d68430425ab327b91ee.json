{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"timing\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport PanResponder from \"react-native-web/dist/exports/PanResponder\";\nimport Keyboard from \"react-native-web/dist/exports/Keyboard\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport View from \"react-native-web/dist/exports/View\";\nimport useAnimatedValue from \"./useAnimatedValue\";\nvar DEAD_ZONE = 12;\nvar DefaultTransitionSpec = {\n  timing: Animated.spring,\n  stiffness: 1000,\n  damping: 500,\n  mass: 3,\n  overshootClamping: true\n};\nexport default function PanResponderAdapter(_ref) {\n  var layout = _ref.layout,\n      _ref$keyboardDismissM = _ref.keyboardDismissMode,\n      keyboardDismissMode = _ref$keyboardDismissM === void 0 ? 'auto' : _ref$keyboardDismissM,\n      _ref$swipeEnabled = _ref.swipeEnabled,\n      swipeEnabled = _ref$swipeEnabled === void 0 ? true : _ref$swipeEnabled,\n      navigationState = _ref.navigationState,\n      onIndexChange = _ref.onIndexChange,\n      onSwipeStart = _ref.onSwipeStart,\n      onSwipeEnd = _ref.onSwipeEnd,\n      children = _ref.children,\n      style = _ref.style;\n  var routes = navigationState.routes,\n      index = navigationState.index;\n  var panX = useAnimatedValue(0);\n  var listenersRef = React.useRef([]);\n  var navigationStateRef = React.useRef(navigationState);\n  var layoutRef = React.useRef(layout);\n  var onIndexChangeRef = React.useRef(onIndexChange);\n  var currentIndexRef = React.useRef(index);\n  var pendingIndexRef = React.useRef();\n  var swipeVelocityThreshold = 0.15;\n  var swipeDistanceThreshold = layout.width / 1.75;\n  var jumpToIndex = React.useCallback(function (index) {\n    var offset = -index * layoutRef.current.width;\n\n    var timing = DefaultTransitionSpec.timing,\n        transitionConfig = _objectWithoutProperties(DefaultTransitionSpec, _excluded);\n\n    Animated.parallel([timing(panX, _objectSpread(_objectSpread({}, transitionConfig), {}, {\n      toValue: offset,\n      useNativeDriver: false\n    }))]).start(function (_ref2) {\n      var finished = _ref2.finished;\n\n      if (finished) {\n        onIndexChangeRef.current(index);\n        pendingIndexRef.current = undefined;\n      }\n    });\n    pendingIndexRef.current = index;\n  }, [panX]);\n  React.useEffect(function () {\n    navigationStateRef.current = navigationState;\n    layoutRef.current = layout;\n    onIndexChangeRef.current = onIndexChange;\n  });\n  React.useEffect(function () {\n    var offset = -navigationStateRef.current.index * layout.width;\n    panX.setValue(offset);\n  }, [layout.width, panX]);\n  React.useEffect(function () {\n    if (keyboardDismissMode === 'auto') {\n      Keyboard.dismiss();\n    }\n\n    if (layout.width && currentIndexRef.current !== index) {\n      currentIndexRef.current = index;\n      jumpToIndex(index);\n    }\n  }, [jumpToIndex, keyboardDismissMode, layout.width, index]);\n\n  var isMovingHorizontally = function isMovingHorizontally(_, gestureState) {\n    return Math.abs(gestureState.dx) > Math.abs(gestureState.dy * 2) && Math.abs(gestureState.vx) > Math.abs(gestureState.vy * 2);\n  };\n\n  var canMoveScreen = function canMoveScreen(event, gestureState) {\n    if (swipeEnabled === false) {\n      return false;\n    }\n\n    var diffX = I18nManager.isRTL ? -gestureState.dx : gestureState.dx;\n    return isMovingHorizontally(event, gestureState) && (diffX >= DEAD_ZONE && currentIndexRef.current > 0 || diffX <= -DEAD_ZONE && currentIndexRef.current < routes.length - 1);\n  };\n\n  var startGesture = function startGesture() {\n    onSwipeStart === null || onSwipeStart === void 0 ? void 0 : onSwipeStart();\n\n    if (keyboardDismissMode === 'on-drag') {\n      Keyboard.dismiss();\n    }\n\n    panX.stopAnimation();\n    panX.setOffset(panX._value);\n  };\n\n  var respondToGesture = function respondToGesture(_, gestureState) {\n    var diffX = I18nManager.isRTL ? -gestureState.dx : gestureState.dx;\n\n    if (diffX > 0 && index <= 0 || diffX < 0 && index >= routes.length - 1) {\n      return;\n    }\n\n    if (layout.width) {\n      var position = (panX._offset + diffX) / -layout.width;\n      var next = position > index ? Math.ceil(position) : Math.floor(position);\n\n      if (next !== index) {\n        listenersRef.current.forEach(function (listener) {\n          return listener(next);\n        });\n      }\n    }\n\n    panX.setValue(diffX);\n  };\n\n  var finishGesture = function finishGesture(_, gestureState) {\n    panX.flattenOffset();\n    onSwipeEnd === null || onSwipeEnd === void 0 ? void 0 : onSwipeEnd();\n    var currentIndex = typeof pendingIndexRef.current === 'number' ? pendingIndexRef.current : currentIndexRef.current;\n    var nextIndex = currentIndex;\n\n    if (Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && Math.abs(gestureState.vx) > Math.abs(gestureState.vy) && (Math.abs(gestureState.dx) > swipeDistanceThreshold || Math.abs(gestureState.vx) > swipeVelocityThreshold)) {\n      nextIndex = Math.round(Math.min(Math.max(0, I18nManager.isRTL ? currentIndex + gestureState.dx / Math.abs(gestureState.dx) : currentIndex - gestureState.dx / Math.abs(gestureState.dx)), routes.length - 1));\n      currentIndexRef.current = nextIndex;\n    }\n\n    if (!isFinite(nextIndex)) {\n      nextIndex = currentIndex;\n    }\n\n    jumpToIndex(nextIndex);\n  };\n\n  var addEnterListener = React.useCallback(function (listener) {\n    listenersRef.current.push(listener);\n    return function () {\n      var index = listenersRef.current.indexOf(listener);\n\n      if (index > -1) {\n        listenersRef.current.splice(index, 1);\n      }\n    };\n  }, []);\n  var jumpTo = React.useCallback(function (key) {\n    var index = navigationStateRef.current.routes.findIndex(function (route) {\n      return route.key === key;\n    });\n    jumpToIndex(index);\n  }, [jumpToIndex]);\n  var panResponder = PanResponder.create({\n    onMoveShouldSetPanResponder: canMoveScreen,\n    onMoveShouldSetPanResponderCapture: canMoveScreen,\n    onPanResponderGrant: startGesture,\n    onPanResponderMove: respondToGesture,\n    onPanResponderTerminate: finishGesture,\n    onPanResponderRelease: finishGesture,\n    onPanResponderTerminationRequest: function onPanResponderTerminationRequest() {\n      return true;\n    }\n  });\n  var maxTranslate = layout.width * (routes.length - 1);\n  var translateX = Animated.multiply(panX.interpolate({\n    inputRange: [-maxTranslate, 0],\n    outputRange: [-maxTranslate, 0],\n    extrapolate: 'clamp'\n  }), I18nManager.isRTL ? -1 : 1);\n  return children({\n    position: layout.width ? Animated.divide(panX, -layout.width) : new Animated.Value(index),\n    addEnterListener: addEnterListener,\n    jumpTo: jumpTo,\n    render: function render(children) {\n      return React.createElement(Animated.View, _extends({\n        style: [styles.sheet, layout.width ? {\n          width: routes.length * layout.width,\n          transform: [{\n            translateX: translateX\n          }]\n        } : null, style]\n      }, panResponder.panHandlers), React.Children.map(children, function (child, i) {\n        var route = routes[i];\n        var focused = i === index;\n        return React.createElement(View, {\n          key: route.key,\n          style: layout.width ? {\n            width: layout.width\n          } : focused ? StyleSheet.absoluteFill : null\n        }, focused || layout.width ? child : null);\n      }));\n    }\n  });\n}\nvar styles = StyleSheet.create({\n  sheet: {\n    flex: 1,\n    flexDirection: 'row',\n    alignItems: 'stretch'\n  }\n});","map":{"version":3,"sources":["PanResponderAdapter.tsx"],"names":["DEAD_ZONE","DefaultTransitionSpec","timing","Animated","stiffness","damping","mass","overshootClamping","keyboardDismissMode","swipeEnabled","style","index","panX","useAnimatedValue","listenersRef","React","navigationStateRef","layoutRef","onIndexChangeRef","currentIndexRef","pendingIndexRef","swipeVelocityThreshold","swipeDistanceThreshold","layout","jumpToIndex","offset","transitionConfig","toValue","useNativeDriver","finished","Keyboard","isMovingHorizontally","Math","gestureState","canMoveScreen","diffX","I18nManager","routes","startGesture","onSwipeStart","respondToGesture","position","next","listener","finishGesture","onSwipeEnd","currentIndex","nextIndex","isFinite","addEnterListener","jumpTo","key","route","panResponder","onMoveShouldSetPanResponder","onMoveShouldSetPanResponderCapture","onPanResponderGrant","onPanResponderMove","onPanResponderTerminate","onPanResponderRelease","onPanResponderTerminationRequest","maxTranslate","translateX","inputRange","outputRange","extrapolate","children","render","styles","width","transform","focused","i","StyleSheet","sheet","flex","flexDirection","alignItems"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  Animated,\n  PanResponder,\n  Keyboard,\n  StyleSheet,\n  GestureResponderEvent,\n  PanResponderGestureState,\n  I18nManager,\n  View,\n} from 'react-native';\nimport useAnimatedValue from './useAnimatedValue';\nimport type {\n  NavigationState,\n  Route,\n  Layout,\n  EventEmitterProps,\n  PagerProps,\n  Listener,\n} from './types';\n\ntype Props<T extends Route> = PagerProps & {\n  layout: Layout;\n  onIndexChange: (index: number) => void;\n  navigationState: NavigationState<T>;\n  children: (\n    props: EventEmitterProps & {\n      // Animated value which represents the state of current index\n      // It can include fractional digits as it represents the intermediate value\n      position: Animated.AnimatedInterpolation;\n      // Function to actually render the content of the pager\n      // The parent component takes care of rendering\n      render: (children: React.ReactNode) => React.ReactNode;\n      // Callback to call when switching the tab\n      // The tab switch animation is performed even if the index in state is unchanged\n      jumpTo: (key: string) => void;\n    }\n  ) => React.ReactElement;\n};\n\nconst DEAD_ZONE = 12;\n\nconst DefaultTransitionSpec = {\n  timing: Animated.spring,\n  stiffness: 1000,\n  damping: 500,\n  mass: 3,\n  overshootClamping: true,\n};\n\nexport default function PanResponderAdapter<T extends Route>({\n  layout,\n  keyboardDismissMode = 'auto',\n  swipeEnabled = true,\n  navigationState,\n  onIndexChange,\n  onSwipeStart,\n  onSwipeEnd,\n  children,\n  style,\n}: Props<T>) {\n  const { routes, index } = navigationState;\n\n  const panX = useAnimatedValue(0);\n\n  const listenersRef = React.useRef<Listener[]>([]);\n\n  const navigationStateRef = React.useRef(navigationState);\n  const layoutRef = React.useRef(layout);\n  const onIndexChangeRef = React.useRef(onIndexChange);\n\n  const currentIndexRef = React.useRef(index);\n  const pendingIndexRef = React.useRef<number>();\n\n  const swipeVelocityThreshold = 0.15;\n  const swipeDistanceThreshold = layout.width / 1.75;\n\n  const jumpToIndex = React.useCallback(\n    (index: number) => {\n      const offset = -index * layoutRef.current.width;\n\n      const { timing, ...transitionConfig } = DefaultTransitionSpec;\n\n      Animated.parallel([\n        timing(panX, {\n          ...transitionConfig,\n          toValue: offset,\n          useNativeDriver: false,\n        }),\n      ]).start(({ finished }) => {\n        if (finished) {\n          onIndexChangeRef.current(index);\n          pendingIndexRef.current = undefined;\n        }\n      });\n\n      pendingIndexRef.current = index;\n    },\n    [panX]\n  );\n\n  React.useEffect(() => {\n    navigationStateRef.current = navigationState;\n    layoutRef.current = layout;\n    onIndexChangeRef.current = onIndexChange;\n  });\n\n  React.useEffect(() => {\n    const offset = -navigationStateRef.current.index * layout.width;\n\n    panX.setValue(offset);\n  }, [layout.width, panX]);\n\n  React.useEffect(() => {\n    if (keyboardDismissMode === 'auto') {\n      Keyboard.dismiss();\n    }\n\n    if (layout.width && currentIndexRef.current !== index) {\n      currentIndexRef.current = index;\n      jumpToIndex(index);\n    }\n  }, [jumpToIndex, keyboardDismissMode, layout.width, index]);\n\n  const isMovingHorizontally = (\n    _: GestureResponderEvent,\n    gestureState: PanResponderGestureState\n  ) => {\n    return (\n      Math.abs(gestureState.dx) > Math.abs(gestureState.dy * 2) &&\n      Math.abs(gestureState.vx) > Math.abs(gestureState.vy * 2)\n    );\n  };\n\n  const canMoveScreen = (\n    event: GestureResponderEvent,\n    gestureState: PanResponderGestureState\n  ) => {\n    if (swipeEnabled === false) {\n      return false;\n    }\n\n    const diffX = I18nManager.isRTL ? -gestureState.dx : gestureState.dx;\n\n    return (\n      isMovingHorizontally(event, gestureState) &&\n      ((diffX >= DEAD_ZONE && currentIndexRef.current > 0) ||\n        (diffX <= -DEAD_ZONE && currentIndexRef.current < routes.length - 1))\n    );\n  };\n\n  const startGesture = () => {\n    onSwipeStart?.();\n\n    if (keyboardDismissMode === 'on-drag') {\n      Keyboard.dismiss();\n    }\n\n    panX.stopAnimation();\n    // @ts-expect-error: _value is private, but docs use it as well\n    panX.setOffset(panX._value);\n  };\n\n  const respondToGesture = (\n    _: GestureResponderEvent,\n    gestureState: PanResponderGestureState\n  ) => {\n    const diffX = I18nManager.isRTL ? -gestureState.dx : gestureState.dx;\n\n    if (\n      // swiping left\n      (diffX > 0 && index <= 0) ||\n      // swiping right\n      (diffX < 0 && index >= routes.length - 1)\n    ) {\n      return;\n    }\n\n    if (layout.width) {\n      // @ts-expect-error: _offset is private, but docs use it as well\n      const position = (panX._offset + diffX) / -layout.width;\n      const next =\n        position > index ? Math.ceil(position) : Math.floor(position);\n\n      if (next !== index) {\n        listenersRef.current.forEach((listener) => listener(next));\n      }\n    }\n\n    panX.setValue(diffX);\n  };\n\n  const finishGesture = (\n    _: GestureResponderEvent,\n    gestureState: PanResponderGestureState\n  ) => {\n    panX.flattenOffset();\n\n    onSwipeEnd?.();\n\n    const currentIndex =\n      typeof pendingIndexRef.current === 'number'\n        ? pendingIndexRef.current\n        : currentIndexRef.current;\n\n    let nextIndex = currentIndex;\n\n    if (\n      Math.abs(gestureState.dx) > Math.abs(gestureState.dy) &&\n      Math.abs(gestureState.vx) > Math.abs(gestureState.vy) &&\n      (Math.abs(gestureState.dx) > swipeDistanceThreshold ||\n        Math.abs(gestureState.vx) > swipeVelocityThreshold)\n    ) {\n      nextIndex = Math.round(\n        Math.min(\n          Math.max(\n            0,\n            I18nManager.isRTL\n              ? currentIndex + gestureState.dx / Math.abs(gestureState.dx)\n              : currentIndex - gestureState.dx / Math.abs(gestureState.dx)\n          ),\n          routes.length - 1\n        )\n      );\n\n      currentIndexRef.current = nextIndex;\n    }\n\n    if (!isFinite(nextIndex)) {\n      nextIndex = currentIndex;\n    }\n\n    jumpToIndex(nextIndex);\n  };\n\n  // TODO: use the listeners\n  const addEnterListener = React.useCallback((listener: Listener) => {\n    listenersRef.current.push(listener);\n\n    return () => {\n      const index = listenersRef.current.indexOf(listener);\n\n      if (index > -1) {\n        listenersRef.current.splice(index, 1);\n      }\n    };\n  }, []);\n\n  const jumpTo = React.useCallback(\n    (key: string) => {\n      const index = navigationStateRef.current.routes.findIndex(\n        (route: { key: string }) => route.key === key\n      );\n\n      jumpToIndex(index);\n    },\n    [jumpToIndex]\n  );\n\n  const panResponder = PanResponder.create({\n    onMoveShouldSetPanResponder: canMoveScreen,\n    onMoveShouldSetPanResponderCapture: canMoveScreen,\n    onPanResponderGrant: startGesture,\n    onPanResponderMove: respondToGesture,\n    onPanResponderTerminate: finishGesture,\n    onPanResponderRelease: finishGesture,\n    onPanResponderTerminationRequest: () => true,\n  });\n\n  const maxTranslate = layout.width * (routes.length - 1);\n  const translateX = Animated.multiply(\n    panX.interpolate({\n      inputRange: [-maxTranslate, 0],\n      outputRange: [-maxTranslate, 0],\n      extrapolate: 'clamp',\n    }),\n    I18nManager.isRTL ? -1 : 1\n  );\n\n  return children({\n    position: layout.width\n      ? Animated.divide(panX, -layout.width)\n      : new Animated.Value(index),\n    addEnterListener,\n    jumpTo,\n    render: (children) => (\n      <Animated.View\n        style={[\n          styles.sheet,\n          layout.width\n            ? {\n                width: routes.length * layout.width,\n                transform: [{ translateX }],\n              }\n            : null,\n          style,\n        ]}\n        {...panResponder.panHandlers}\n      >\n        {React.Children.map(children, (child, i) => {\n          const route = routes[i];\n          const focused = i === index;\n\n          return (\n            <View\n              key={route.key}\n              style={\n                layout.width\n                  ? { width: layout.width }\n                  : focused\n                  ? StyleSheet.absoluteFill\n                  : null\n              }\n            >\n              {focused || layout.width ? child : null}\n            </View>\n          );\n        })}\n      </Animated.View>\n    ),\n  });\n}\n\nconst styles = StyleSheet.create({\n  sheet: {\n    flex: 1,\n    flexDirection: 'row',\n    alignItems: 'stretch',\n  },\n});\n"]},"metadata":{},"sourceType":"module"}